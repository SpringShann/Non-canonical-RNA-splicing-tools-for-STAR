# Overview

This repository contains a collection of tools built around the **RNA STAR aligner** for the downstream processing, quantification, and visualization of **non-canonical RNA splice sites**.

It primarily serves as the public analysis repository associated with the manuscript *The “Cutting Edge” of Non-canonical RNA Splicing*. At the same time, the tools can be adapted and customized for the analysis of user-generated datasets.

The included **STAR output files** and selected example outputs correspond directly to the datasets analyzed in the manuscript.



# 1. Non-canonical site remapper (1-manual-mapping.py)

This program is designed to systematically identify and classify **non-canonical splice junctions** from the `SJ.out.tab` file generated by **STAR**. It also performs a remapping-based inference of the most likely associated gene for each junction, enabling downstream inspection and quantitative analysis.

The script is intended to help researchers extract, annotate, and organize non-canonical splice sites for further statistical analysis and experimental interpretation.

⚠️ Note that a portion of the data processing in the manuscript did not use this program, but rather an earlier version of it. See “**Simple remapper**” after this.

## Inputs

The program requires the following inputs:

1. A **GTF gene annotation file** used for remapping and gene assignment
2. A **reference genome** in **FASTA** format
3. The **`SJ.out.tab`** file generated by **STAR**
4. An optional **STAR-aligned BAM file** for traceback of supporting read names
5. An **output path** for the result file
6. A user-defined **flanking length (in bp)** to extract sequence context upstream and/or downstream of each non-canonical splice site

## Output Format

Each splice junction is reported as a **two-line output unit**.

### Line 1: Primary junction record (8 columns)

The first line contains the core annotation for a non-canonical splice junction:

1. **Read identifier**
   If a BAM file is provided, the script attempts to recover the name of one read that exactly supports the junction. Otherwise, a placeholder identifier in the format `JUNC_chr_start_end` is used.
2. **Junction start coordinate**
3. **Junction end coordinate**
4. **Strand**
5. **Splice motif**
   Reported as `donor/acceptor` in transcript-oriented 5'→3' direction
6. **Inferred gene ID**
7. **Intron length**
8. **Number of uniquely supporting reads**

### Line 2: Sequence context record (6 columns)

The second line provides the local sequence context surrounding the splice junction:

1. **Context marker** (`#context`)
2. **Donor-upstream label** (e.g., `donor_up(10bp):`)
3. **Donor-side sequence context**
4. **Acceptor-downstream label** (e.g., `acceptor_down(10bp):`)
5. **Acceptor-side sequence context**
6. **Strand source**
   Indicates whether strand assignment was derived from **STAR**, **GTF**, or remained **Unknown**

All sequence context is reported in a consistent **transcript-oriented 5'→3' direction**.



# 2. Simple remapper (2-simple-remapper.py)

This is an earlier version of the above program (**`1-manual-mapping.py`**) with simpler output. While not as intuitive in visualization as the later program, its output may be more suitable for subsequent machine processing.

This script can be used to classify and remap either **canonical** or **non-canonical** splice junctions from **STAR** output, with the selection controlled by a single filtering line.

## Inputs

This script requires the following input files and parameters:

1. **GTF annotation file**
   A gene annotation file in **GTF** format. The script uses `gene` entries to assign each splice junction to a putative host gene and, when necessary, to infer strand orientation.
2. **Reference genome FASTA**
   A genomic reference sequence in **FASTA** format. This is used together with `samtools faidx` to extract splice-site sequences.
3. **STAR `SJ.out.tab` file**
   The splice junction output generated by **STAR**. This file provides genomic coordinates, strand codes, splice motif codes, and read support values for each detected junction.
4. **Output path**
   The path to the output file where the annotated junction table will be written.

## Filtering Behavior

By default, the script is configured to retain **non-canonical** splice junctions only:

```
sj_df = sj_df[sj_df["motif_code"] == 0]
```

If this line is changed to:

```
sj_df = sj_df[sj_df["motif_code"] != 0]
```

the script will instead retain and analyze **canonical** splice junctions.

In addition, the script applies a minimum read-support filter:

- `unique_reads > 1`

## Output

The script produces a tab-delimited text file containing one row per retained splice junction. The output table has **10 columns**:

1. **chr**
   Chromosome or reference sequence name.
2. **start**
   Junction start coordinate.
3. **end**
   Junction end coordinate.
4. **strand**
   Strand code used in the final output. In this script, strand is represented numerically:
   - `0` = undefined
   - `1` = positive strand
   - `2` = negative strand
5. **strand_source**
   Source of strand assignment:
   - `STAR` if directly provided by STAR
   - `GTF` if inferred from the GTF annotation when STAR reports strand as undefined
   - `Unknown` if strand cannot be resolved
6. **motif**
   The inferred splice-site dinucleotide motif, reported as `donor/acceptor`.
7. **intron_length**
   Intron length, calculated as `end - start`.
8. **gene_id**
   The gene identifier assigned by overlap with GTF `gene` annotations. If no overlapping gene is found, this field is reported as `NA`.
9. **unique_reads**
   Number of uniquely mapped reads supporting the junction.
10. **multi_reads**
    Number of multi-mapped reads supporting the junction.

## Example Output

A typical output row is structured as follows:

```
NC_000072.7 143153044 143153064 1 GTF TG/GA 20 Etnk1 43 4
```

This indicates a splice junction on chromosome `NC_000072.7`, spanning positions `143153044–143153064`, assigned to the positive strand (`1`) based on **GTF** inference, with motif `TG/GA`, intron length `20 bp`, mapped to gene `Etnk1`, and supported by `43` uniquely mapped reads and `4` multi-mapped reads.



# 3. Dinucleotide Site Frequency Heatmap (3-dinuc-heatmap.py)

This script parses `#context` lines from a splice-junction validation TSV file, extracts the 2-bp **donor** and **acceptor** splice-site motifs, counts their dinucleotide frequencies, and generates both tabular summaries and heatmap visualizations.

It is designed for downstream analysis of splice-site sequence composition, particularly for examining donor- and acceptor-side dinucleotide usage across a set of validated junctions.

## Overview

For each `#context` line in the input file, the script:

1. extracts the bracketed 2-bp donor site from the donor context field
2. extracts the bracketed 2-bp acceptor site from the acceptor context field
3. retains only valid dinucleotides composed of `A`, `C`, `G`, and `T`
4. optionally excludes specified motifs (by default, donor `GT` and acceptor `AG`)
5. counts dinucleotide occurrences separately for donor and acceptor sites
6. converts the counts into 4×4 matrices
7. computes normalized frequency matrices
8. exports both TSV tables and heatmap figures for counts and frequencies

## Input

The script requires a single input TSV file provided with:

```
--tsv
```

### Input format requirements

The input file can be directly imported from the output of Non-canonical site remapper (**`1-manual-mapping.py`**). It should:

- be a **tab-delimited text file**
- contain lines beginning with `#context`
- store donor and acceptor sequence context in the same format used by the validation script
- include the splice-site dinucleotide enclosed in square brackets, for example:

`GGAGCTAGTG[GT]`
`[AG]CTACGAGAAA`

The script reads:

- the **donor field** from column 3
- the **acceptor field** from column 5

and extracts the bracketed sequence from each field.

## Output

The script writes the following files to the output directory specified by:

```
--outdir
```

### Donor-site outputs

1. **`donor_site2_exclGT_counts.tsv`**
   Raw 2-bp donor dinucleotide counts in a 4×4 matrix.
2. **`donor_site2_exclGT_freq.tsv`**
   Normalized donor dinucleotide frequencies.
3. **`donor_site2_exclGT_heatmap_counts.<format>`**
   Heatmap of donor dinucleotide counts.
4. **`donor_site2_exclGT_heatmap_freq.<format>`**
   Heatmap of donor dinucleotide frequencies.

### Acceptor-site outputs

1. **`acceptor_site2_exclAG_counts.tsv`**
   Raw 2-bp acceptor dinucleotide counts in a 4×4 matrix.
2. **`acceptor_site2_exclAG_freq.tsv`**
   Normalized acceptor dinucleotide frequencies.
3. **`acceptor_site2_exclAG_heatmap_counts.<format>`**
   Heatmap of acceptor dinucleotide counts.
4. **`acceptor_site2_exclAG_heatmap_freq.<format>`**
   Heatmap of acceptor dinucleotide frequencies.

The output image format is controlled by `--format` and may be `png`, `pdf`, or `svg`.

## Filtering Behavior

By default, the script excludes the canonical splice-site dinucleotides:

- **donor `GT`**
- **acceptor `AG`**

This filtering is performed in the `extract_sites_from_context()` function.

Specifically, the following logic removes these motifs before counting:

- donor `GT` is discarded
- acceptor `AG` is discarded

This behavior is **not fixed**. It can be changed easily by editing or commenting out the corresponding filtering lines in the function. In other words, the script can be used either:

- to analyze **non-canonical-enriched** dinucleotide usage by excluding canonical motifs, or
- to analyze **all detected dinucleotides** by disabling the exclusion logic

If the filtering lines are commented out, the script will retain canonical donor `GT` and acceptor `AG` along with all other valid 2-bp motifs.

## Matrix Format

The count and frequency tables are written as **4×4 matrices** with:

- rows representing the **first base**
- columns representing the **second base**

Both axes follow the same nucleotide order:

```
A, C, G, T
```

Thus, each matrix cell corresponds to one dinucleotide (e.g., `GT`, `AG`, `CC`).

## Visualization

For both donor and acceptor sites, the script generates:

- one heatmap for **raw counts**
- one heatmap for **normalized frequencies**

Each heatmap:

- is rendered at high resolution
- supports transparent background export
- displays the numeric value in each cell
- uses the same 4×4 nucleotide layout as the TSV matrices

## Command-Line Arguments

- **`--tsv`**
  Input TSV containing `#context` lines
- **`--outdir`**
  Output directory
- **`--dpi`**
  Output resolution (default: `600`)
- **`--format`**
  Output image format: `png`, `pdf`, or `svg` (default: `png`)
- **`--transparent`**
  Enables transparent background output

## Notes

- Only valid 2-bp sequences composed of `A`, `C`, `G`, and `T` are counted.
- Any malformed or missing bracketed sequence is ignored.
- Donor and acceptor sites are counted independently.
- If all sites are filtered out for one category, the corresponding frequency matrix remains zero-filled.

## Typical Use Case

This script is useful for summarizing splice-site dinucleotide composition after junction validation, especially when comparing the sequence landscape of non-canonical splice sites or exploring motif enrichment after excluding the dominant canonical `GT-AG` pattern.

# 4. Intron Length Comparison (4-intron-length-comparison.py)

This script compares the intron length distributions of **canonical** and **non-canonical** splice junctions and generates publication-quality summary plots and descriptive statistics.

It reads one canonical input table and one non-canonical input table, extracts intron lengths from a fixed column in each file, and performs the following analyses:

- plots the **empirical cumulative distribution function (ECDF)** of intron length after **log10 transformation**
- plots a **boxplot** of raw intron lengths on a **log-scaled y-axis**
- computes summary statistics for each group
- performs a **two-sided Mann–Whitney U test** (Wilcoxon rank-sum test) to assess whether the two distributions differ

The script is intended for downstream comparison of splice-junction intron length profiles after STAR-based junction classification and annotation.

## Inputs

You can directly use the output from **`2-simple-remapper.py`** as the input for this script.  The script requires three command-line arguments:

1. **`canonical_txt`**
    Path to the canonical splice-junction table.
2. **`noncanonical_txt`**
    Path to the non-canonical splice-junction table.
3. **`outdir`**
    Path to the output directory.

### Input format requirements

Both input files must be:

- **tab-delimited text files**
- readable without a header row
- structured so that **column 7** contains the intron length values

The script reads intron length from **column 7** in both files and retains only valid numeric values greater than 0.

## Outputs

The script writes the following files to the output directory:

1. **`intron_length_cdf_log10.png`**
2. **`intron_length_cdf_log10.pdf`**
3. **`intron_length_cdf_log10.svg`**

These files contain the ECDF plot of **log10-transformed intron lengths** for canonical and non-canonical junctions.

1. **`intron_length_boxplot_log10.png`**
2. **`intron_length_boxplot_log10.pdf`**
3. **`intron_length_boxplot_log10.svg`**

These files contain the boxplot of intron lengths for both groups, displayed on a **log-scaled y-axis**.

1. **`summary_and_stats.txt`**

This file contains:

- descriptive statistics for canonical junctions
- descriptive statistics for non-canonical junctions
- the result of the Mann–Whitney U test

## Statistical Analysis

The script computes the following descriptive statistics for each group:

- sample size (`n`)
- minimum
- first quartile (`q1`)
- median
- mean
- third quartile (`q3`)
- maximum

For inferential comparison, the script performs a **two-sided Mann–Whitney U test** (`scipy.stats.mannwhitneyu` with `alternative="two-sided"`), which is a nonparametric rank-based test for comparing two independent distributions.

This test is appropriate here because intron lengths are typically highly skewed and can span several orders of magnitude, making a rank-based comparison more robust than a normality-dependent parametric test.

If `scipy` is not installed, or if either group is empty, the statistical test is skipped and only summary statistics are reported.

## Notes

- The ECDF plot uses **log10-transformed intron lengths**.
- The boxplot uses the **raw intron lengths** but displays them on a **log-scale y-axis**.
- Figures are exported in **PNG, PDF, and SVG** formats with a transparent background.
- The script assumes a fixed input-table structure. If the intron length column changes, the column index in the code must be updated accordingly.



